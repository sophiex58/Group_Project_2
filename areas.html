<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Areas with evenly spaced points</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/journal.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 61px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h2 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h3 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h4 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h5 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h6 {
  padding-top: 66px;
  margin-top: -66px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">MAS 115</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Initial Task</a>
</li>
<li>
  <a href="determinants.html">Determinants</a>
</li>
<li>
  <a href="int_coordinates.html">Integer Coordinates</a>
</li>
<li>
  <a href="areas.html">Areas with evenly spaced points</a>
</li>
<li>
  <a href="level_sets.html">Level Sets</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Areas with evenly spaced points</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#function-which-generates-circular-polygons">function which generates circular polygons</a><ul>
<li><a href="#below-we-investigate-further-the-impact-of-using-more-test-points-and-more-repetitions.">Below we investigate further the impact of using more test points and more repetitions.</a></li>
<li><a href="#advancing-the-monte-carlo-method-to-give-a-more-accurate-approximation-for-the-area">advancing the Monte Carlo method to give a more accurate approximation for the area</a></li>
<li><a href="#function-generating-test-points-in-a-grid-pattern">function generating test points in a grid pattern</a></li>
<li><a href="#squared-grid">Squared Grid</a></li>
<li><a href="#triangular-grid">Triangular Grid</a></li>
</ul></li>
</ul>
</div>

<p>a</p>
<p>As mentioned briefly in the initial task, we believe if we increased the number of test points and the number of repetitions to find the mean for the Monte Carlo method the approximation will become closer and closer to the actual are area of the polygon. Here this will be investigated further using regular circular convex polygons and try and provide evidence to back up our hypothesis.</p>
<div id="function-which-generates-circular-polygons" class="section level2">
<h2>function which generates circular polygons</h2>
<pre class="r"><code>#Construct regular polygon with n vertices
vertex_finder &lt;- function(vertices, radius){
  x_coords &lt;- vector(mode = &quot;numeric&quot;, length=vertices) #creates vectors of values to replce.
  y_coords &lt;- vector(mode = &quot;numeric&quot;, length=vertices)#creates vectors of values to replce.
  angle_step &lt;- (2 *pi)/vertices # calculates the angle to increment by each time
  angle &lt;- 0
  for(i in 1:vertices){ #cycles through 1 to vertices.
    x_coords[i] &lt;- cos(angle)*radius #find x compondent of the coordinate with angle
    #and radius.
    y_coords[i] &lt;- sin(angle)*radius #find y compondent of the coordinate with angle
    #and radius.
    angle = angle + angle_step #increase angle by angle_step
  }
  points.angle &lt;- list(x_coords = x_coords, y_coords = y_coords, angle_step, radius)
  return(points.angle)
}
max_vertices &lt;- 10
plot(0, main=&quot;Regular Polygons In a Circle&quot; ,type=&quot;n&quot;, xlab=&quot;x&quot;, ylab=&quot;y&quot;, 
     xlim=c(-10, 10), ylim=c(-10, 10), asp = 1) #creates a plot looking at -10 to 10
#in both x and y axis
for(i in 3:max_vertices){
  polygon(vertex_finder(i, 10)[[1]],vertex_finder(i, 10)[[2]])
}</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>When coding the function for finding the vertices of a regular circular polygon, we first thought about how we would generate the coordinates and looked in to polar coordinates. Knowing this we could easy calculate the angle step by <span class="math inline">\(2\pi/vertices\)</span> as well as entering a real number for the radius. Knowing this we defined the function <span class="math inline">\(vertex\)</span>_<span class="math inline">\(finder\)</span> with the requirements of needing a natural number input for the number of vertices and a real number for the radius. This is just simple conversion to polar coordinates with <span class="math inline">\(x = cos(angle)*radius\)</span> and <span class="math inline">\(y = sin(angle)*radius\)</span> where the angle is incremented by the angle step.</p>
<p>We then went on to define the variables <span class="math inline">\(x\)</span>_ <span class="math inline">\(coords\)</span> and <span class="math inline">\(y\)</span>_ <span class="math inline">\(coords\)</span> to be vectors with the same length as the number of vertices described by the function input <span class="math inline">\(vertices\)</span>. This will allow me to cycle through later changing each indexed value of zero in the vector to the correct coordinate point. For the main chunk of the function we use a for loop to cycle through one to <span class="math inline">\(vertices\)</span> creating the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> coordinates based on the angle between the vertex and the horizontal. This angle is generated by starting at zero then within each iteration of the for loop the angle is increased by the angle step, as previously mentioned, until rotated <span class="math inline">\(2\pi\)</span>. Once all of the vertices have been calculated we store both <span class="math inline">\(x\)</span>_ <span class="math inline">\(coords\)</span> and <span class="math inline">\(y\)</span>_ <span class="math inline">\(coords\)</span> in a list called <span class="math inline">\(points.angle\)</span> as well as the angle increments that achieved these coordinates. This list is then returned from the function.</p>
<p>As we stated before we want to to test if increasing the the number of points generated using the Monte Carlo process and if we increase the number of repetitions to find the mean give a better approximation of the area of the polygon. To do this we will use the function above to generate a pentagon to test the hypothesis.</p>
<pre class="r"><code>radius &lt;- 10
x_1 &lt;- vertex_finder(5,radius)[[1]] #recals the function that generates the coordinates for a regular circular polygon.
y_1 &lt;- vertex_finder(5,radius)[[2]] #y coordinates for vertices
no.points &lt;- 10000 #number of test points to generate  and determine if in or outside the polygon.
areas &lt;- 0
repetitions &lt;- 15
for(i in 1:repetitions){# retpeats monte carlo method 10 times and finds an average for the approximate area
  monte.carlo.points.x &lt;- runif(runif(no.points,-radius-5, radius+5)) #generates random points over polygon dimensions.
  monte.carlo.points.y &lt;- runif(runif(no.points,-radius-5, radius+5))
  areas &lt;- c(areas, point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte2&quot;, plot = 0)) #monte carlo proccess
  
}
point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte2&quot;, plot = 1) #monte carlo proccess</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre><code>## [1] 900</code></pre>
<p>Here is the Monte Carlo process we used before on a circular polygon which has been generated by the <span class="math inline">\(vertex\)</span> _<span class="math inline">\(finder\)</span> function. We used 15 repetitions of the process to calculate a mean approximation for the area which should be closer to the actual area than if we simply did one repetition.</p>
<div id="below-we-investigate-further-the-impact-of-using-more-test-points-and-more-repetitions." class="section level3">
<h3>Below we investigate further the impact of using more test points and more repetitions.</h3>
<pre class="r"><code>radius &lt;- 10
x_1 &lt;- vertex_finder(5,radius)[[1]] #recals the function that generates the coordinates for a regular circular polygon.
y_1 &lt;- vertex_finder(5, radius)[[2]]
no.points &lt;- 10000 #number of test points to generate  and determine if in or outside the polygon.
areas.rep &lt;- 0
for(repetitions in 1:100){
  areas &lt;- 0
  for(i in 1:repetitions){# retpeats monte carlo method 10 times and finds an average for the approximate area
    monte.carlo.points.x &lt;- runif(no.points,-radius-5, radius+5) #generates random points over polygon dimensions.
    monte.carlo.points.y &lt;- runif(no.points,-radius-5, radius+5)
    areas &lt;- c(areas, point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte2&quot;, plot = 0)) #monte carlo proccess
  }
  #point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte&quot;, plot = 1) #monte carlo proccess
  areas.rep &lt;- c(areas.rep,mean(areas[-1]))
}
plot(x = 1:100,areas.rep[-1], main = &quot;Relationship between area and number of repetitions used to find the mean&quot;,xlab = &quot;Number of Repetitions&quot;, ylab = &quot;Area Approximation&quot;)</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code>radius &lt;- 10
x_1 &lt;- vertex_finder(5,radius)[[1]] #recals the function that generates the coordinates for a regular circular polygon.
y_1 &lt;- vertex_finder(5,radius)[[2]]
no.points &lt;- 1000 #number of test points to generate  and determine if in or outside the polygon.
areas.points &lt;- 0
area &lt;- 0
while( no.points &lt;= 100000){# retpeats monte carlo method 10 times and finds an average for the approximate area
  area &lt;- 0
  monte.carlo.points.x &lt;- runif(no.points,-radius-5, radius+5) #generates random points over polygon dimensions.
  monte.carlo.points.y &lt;- runif(no.points,-radius-5, radius+5)
  area &lt;- point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte2&quot;, plot = 0) #monte carlo proccess
  areas.points &lt;- c(areas.points,area)
  no.points &lt;- no.points + 1000
}
plot(1:(length(areas.points)-1)*1000,areas.points[-1], main = &quot;Relationship between area and number of points generated&quot;,xlab = &quot;Number of Points&quot;, ylab = &quot;Area Approximation&quot;)</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>monte.carlo.points.x &lt;- runif(no.points,-radius-5, radius+5) #generates random points over polygon dimensions.
monte.carlo.points.y &lt;- runif(no.points,-radius-5, radius+5)
area &lt;- point_in_out(x_1,y_1,monte.carlo.points.x,monte.carlo.points.y, &quot;Monte2&quot;, plot = 0) #monte carlo proccess</code></pre>
<p>Looking at what happens when we increase the number of points in the Monte Carlo process we can clearly see that the approximate area does converge to the actual area of the polygon we wish to find the area of and if we set the number of points high enough, ie if the number of points is infinity then the area would be an exact approximation. Likewise, if we vary the number of repetitions used to calculate the mean area with a fixed number of points, the approximate area converges to the actual area. After a lot of testing we came to the conclusion believe a balance between the two gives a great approximation. This is because It takes in to account that for smaller values for the number of points use will generally have a high standard deviation and variance from the mean approximate area. If we increase the number of repetitions, this is slightly mitigated, and the law of large number starts to become present.</p>
</div>
<div id="advancing-the-monte-carlo-method-to-give-a-more-accurate-approximation-for-the-area" class="section level3">
<h3>advancing the Monte Carlo method to give a more accurate approximation for the area</h3>
<p>Alongside this, I decided it was interesting to see if it was possible to advance the Monte Carlo method to give a more accurate approximation for the area. I coupled this with the area of regular convex polygons as it gives me a large range or shapes to test using different methods.</p>
<pre class="r"><code>grid_generator &lt;- function(interval, x_1, y_1){#Function to generate the x and y
  grid.points.x &lt;- seq(-radius-5, radius+5,  by=interval)#Define sequence for x values across the x range
  grid.points.y &lt;- seq(-radius-5, radius+5,  by=interval)#Define sequence for y values across the y range
  grid.points.x2 &lt;- floor(max(x_1)+500)#Initialise an extreme value
  grid.points.y2 &lt;- floor(max(y_1)+500)#Initialise an extreme value
  for(i in 1:length(grid.points.x)){#cycle through x values.
    for(n in 1:length(grid.points.y)){ #cycles each y for each x.
      grid.points.x2 &lt;- c(grid.points.x2, grid.points.x[i])#contains the x aspect of the coordinates
      grid.points.y2 &lt;- c(grid.points.y2, grid.points.y[n])#contains the y aspect of the coordinates
    }
  }
  grid.points.x2 &lt;- grid.points.x2[grid.points.x2!= floor(max(x_1)+500)]#removes the extreme value of x.
  grid.points.y2 &lt;- grid.points.y2[grid.points.y2!= floor(max(y_1)+500)]#removes the extreme value of x.
  retlist &lt;- list(grid.points.x2, grid.points.y2,length(grid.points.x2))#list containing all the information generated from the function.
  return(retlist)
}</code></pre>
<p>Rather than using randomly generated points in a range like the Monte Carlo method, we thought about using test points in a grid layout with the hopes of increasing the accuracy of the approximation. We created a function that generates all the test points in a grid pattern, which are then substituted in to the first function we described for testing whether points were in or out of the polygon. This function is named <span class="math inline">\(grid\)</span> _<span class="math inline">\(generator\)</span>. This function takes in a value for the interval, which is defined before the function is run as well as the coordinates of the polygon. This is used to generate the grid over the whole polygon, with points in and out of the polygon. The function works by creating two sequences one for the <span class="math inline">\(x\)</span> part of the coordinate and another for the <span class="math inline">\(y\)</span>. Because We am trying to generate the test points in a square grid all the points in the same column will have the same <span class="math inline">\(x\)</span> part and vice versa for the rows. Knowing this we use two iteration loops to first cycle through the <span class="math inline">\(x\)</span> coordinates and within this the second to for each <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> is assigned to it. This is repeated for all the <span class="math inline">\(x\)</span> values. In addition, two vectors with length that applies to the number of points specified are generated. This is then returned from the function.</p>
</div>
<div id="function-generating-test-points-in-a-grid-pattern" class="section level3">
<h3>function generating test points in a grid pattern</h3>
<pre class="r"><code>radius &lt;- 10
grid_generator2 &lt;- function(interval, x_1, y_1){#Function to generate the x and y 
  grid.points.x &lt;- seq(-radius-5, radius+5,  by=interval)
  grid.points.y &lt;- seq(-radius-5, radius+5,  by=interval)
  grid.points.x2 &lt;- radius+500
  grid.points.y2 &lt;- radius+500
  for(i in 1:length(grid.points.x)){#cycle through x values.
      for(n in 1:length(grid.points.y)){#cycle through y values.
        if(n%%2){#if row is even indexed shifts x aspect by half interval, creating triangular grid.
          grid.points.x2 &lt;- c(grid.points.x2, (grid.points.x[i]+(interval/2)))#contains the x aspect of the coordinates
          grid.points.y2 &lt;- c(grid.points.y2, grid.points.y[n])#contains the x aspect of the coordinates
          
        }
        else{#if odd same as square.
          grid.points.x2 &lt;- c(grid.points.x2, grid.points.x[i])#contains the x aspect of the coordinates
          grid.points.y2 &lt;- c(grid.points.y2, grid.points.y[n])#contains the x aspect of the coordinates
      }
    }
  }
  test &lt;- (grid.points.x2 &gt;= (radius+5))#removes the end most shifteted points, that are now outside of the allowed range. 
  for(i in 1:(length(grid.points.x2))){ #this then cycles through the x and coordinates and sets to point outside area to be removed.
    if(test[i] == TRUE){
      grid.points.x2[i] &lt;- radius+500
      grid.points.y2[i] &lt;- radius+500
    }
  }
  grid.points.x2 &lt;- grid.points.x2[grid.points.x2!= radius+500] #removes the extreme value of x.
  grid.points.y2 &lt;- grid.points.y2[grid.points.y2!= radius+500] #removes the extreme value of x.
  retlist &lt;- list(grid.points.x2, grid.points.y2, length(grid.points.x2))
  return(retlist)
}</code></pre>
<p>Along the same lines as this, we also created another function, which generates a triangular grid of test points rather than a square. We wanted to see if there was any difference in the approximation of the area calculated and which was more accurate. This function was very similar to the previous square grid generator. However, it checks if the row indexing is even and if so all the <span class="math inline">\(x\)</span> values of the even indexed rows are incremented by half the interval specified creating the triangular grid. This effectively shifted the even lines to the right giving us a triangular grid. We realized this pushed some values out of the range, so we had to remove them, using the same method as when we test if a point if in a polygon from earlier.</p>
</div>
<div id="squared-grid" class="section level3">
<h3>Squared Grid</h3>
<pre class="r"><code>#Squared grid
#Generates a regular circular polygon with radius and number of vertices choosen by user.
radius &lt;- 10
x_1 &lt;- vertex_finder(5,radius)[[1]] #recals the function that generates the coordinates for a regular circular polygon.
y_1 &lt;- vertex_finder(5,radius)[[2]]
no.points &lt;- 1000 #specify number of points to generate
interval &lt;- ((radius+5) - (-radius-5))/ceiling(sqrt(no.points)-1) #determines interval based on number of desired points.
point_in_out(x_1,y_1,grid_generator(interval, x_1, y_1)[[1]], grid_generator(interval, x_1, y_1)[[2]], type = &quot;GRID_1&quot;, plot = 1)</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<pre><code>## [1] 219.7266</code></pre>
<pre class="r"><code>area_calculator(x_1,y_1)</code></pre>
<pre><code>## [1] 237.7641</code></pre>
</div>
<div id="triangular-grid" class="section level3">
<h3>Triangular Grid</h3>
<pre class="r"><code>#triangular grid
#test with triangular grid
radius &lt;- 10
x_1 &lt;- vertex_finder(5,radius)[[1]] #recals the function that generates the coordinates for a regular circular polygon.
y_1 &lt;- vertex_finder(5,radius)[[2]]
no.points &lt;- 1000 #the actual number of points is -50 due to the shift to the right.
interval &lt;- (ceiling(max(x_1)+5) - floor(min(x_1)-5))/ceiling(sqrt(no.points)-1) #determines interval based on number of desired points.
point_in_out(x_1,y_1,grid_generator2(interval, x_1, y_1)[[1]],grid_generator2(interval, x_1, y_1)[[2]], type = &quot;GRID_2&quot;, plot = 1)</code></pre>
<p><img src="areas_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre><code>## [1] 228.213</code></pre>
<pre class="r"><code>area_calculator(x_1,y_1)</code></pre>
<pre><code>## [1] 237.7641</code></pre>
<p>When comparing the data from both the square grid approximation and the triangular grid approximation, we found that both do approach the actual area of the polygon. However my hypothesis which stated that if the points are equally spread out in a grid format the approximate area calculated will be closer than the Monte Carlo method due to this even spaced properties. After rigorous of testing with increasing number of the points for both the square grid and triangular, we found that the Monte Carlo method provided the closest approximation to the actual area. This could be down to small errors in my code that we have not accounted for as we have used the same approach as the Monte Carlo for determining the approximate area.</p>
<p>In the above examples of the code that generates the square and triangular grids we choose to use one thousand points so that you can clearly see the pattern which is generated. Further data with points greater than this is below however it is difficult to see the pattern with the number of points greater than one thousand.</p>
<div class="figure">
<img src="images/triange_grid_data.png" alt="caption" />
<p class="caption">caption</p>
</div>
<p><br><br><br><br></p>
<div class="figure">
<img src="images/square_grid_data.png" alt="caption" />
<p class="caption">caption</p>
</div>
<p>In the above tables are my findings you can see how the approximate area changes with more points in both the square grid and the triangle grid method. We used those specific number of points to test because they are all square number so will perfectly fit in a square or triangular format.</p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
